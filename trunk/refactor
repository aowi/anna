Config
======
Internally, Anna^ uses a sqlite-table with configuration. Each change is 
written to the database and, on demand, to the config-file. Each request for a
config-object, returns whatever is in the table at the moment.

Authentication
==============
Anna^ keeps track of authentications with a sqlite table. Authentications can 
be hooked to nickserv-registration (so registered users automagically are 
authenticated). Anna^ will clear the authentication table upon initial startup, 
unless explicitly told not to (if you wish to keep peoples auths during an 
upgrade or the like. There _shouldn't_ be a problem with this, since auth's 
will be cross-referenced with user hostmasks/cloaks.


Heap-object:

$heap
	irc	=> irc-object
	auth	=>
		<host> =>
			user	=> <username>
			nick 	=> <irc_nick>
	modules	=>
		<module_name>	=>
			[local module-heap]
	
Modules
=======
Each module reside in a separate namespace under Anna::Module (e.g. 
Anna::Module::haiku). On load, the module is eval'd in that particular 
namespace. 
Here, it can hook up to various commands via the Anna::command_bind function, 
match regexps via Anna::regexp_bind and more. When an appropriate command is 
found, Anna^ will call the Anna::Module::module_name::sub that's associated with
the specific command. On unload, the namespace Anna::Module::module_name is 
destroyed (is this possible?) [I think not, but we might be able to override it
with an empty enviroment]

Possible to handle commands with POE-events using postback and callback 
instead? Might make module-loading a whole lot easier.

Git-stuff
========
git-clone git://frokostgruppen.dk/var/git/anna.git
git-commit, git-push and so on

Multiple networks
Each network is assigned a session. Default session
handlers will handle events for single sessions.
This means it's not directly possible (or rather, 
somewhat messy) to access stack-information for 
another network. As of this time, it seems like a 
reasonable constraint.
